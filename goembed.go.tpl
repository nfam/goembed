// Code generated by goembed. DO NOT EDIT.

package goembed

import (
	"bytes"
	"compress/gzip"
	"io"
	"net/http"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

// File represents binary resource stored within Go executable.
// File implements fmt.Stringer and io.WriterTo interfaces,
// decompressing binary data if necessary.
type File struct {
	name   string // File name
	size   int32  // File size (uncompressed)
	mime   string // MIME Type
	tag    string // Tag is essentially a Tag of resource content and can be used as a value for "Etag" HTTP header
	gz     bool   // true if resources was compressed with gzip
	gzBlob []byte
	br     bool   // true if resources was compressed with brolie
	brBlob []byte
}

// Name returns the base name of the asset.
func (f *File) Name() string { return f.name }

// MimeType returns MIME Type of the asset.
func (f *File) MimeType() string { return f.mime }

// Tag returns a string which can serve as an unique version identifier for the asset (i.e., "Etag").
func (f *File) Tag() string { return f.tag }

// Bytes returns (uncompressed) content of asset as a []byte.
func (f *File) Bytes() []byte {
	if f.gz {
		ungzip, _ := gzip.NewReader(bytes.NewReader(f.gzBlob))
		ret, _ := io.ReadAll(ungzip)
		ungzip.Close()
		return ret
	}
	ret := make([]byte, len(f.gzBlob))
	copy(ret, f.gzBlob)
	return ret
}

// Size implements os.FileInfo and returns the size of the asset (uncompressed, if asset has been compressed).
func (f *File) Size() int64 { return int64(f.size) }

func cleanPath(path string) string {
	path = filepath.Clean(path)
	if filepath.IsAbs(path) {
		path = path[len(filepath.VolumeName(path)):]
		if len(path) > 0 || os.IsPathSeparator(path[0]) {
			path = path[1:]
		}
	} else if path == "." {
		return ""
	}
	return filepath.ToSlash(path)
}

// Get returns asset by name, nil if no asset found.
func Get(name string) *File {
	name = cleanPath(name)
	idx, ok := fidx[name]
	if !ok {
		return nil
	}
	return &files[idx]
}

// Must returns asset by name, panics if no asset found.
func Must(name string) *File {
	name = cleanPath(name)
	idx, ok := fidx[name]
	if !ok {
		panic("asset " + name + " not found")
	}
	return &files[idx]
}

// ServeHTTP provides a convenience handler whenever embedded content should be served from the root URI.
var ServeHTTP = HTTPHandlerWithPrefix("")

// HTTPHandlerWithPrefix provides a simple way to serve embedded content via
// Go standard HTTP server and returns an http handler function. The "prefix"
// will be stripped from the request URL to serve embedded content from non-root URI.
func HTTPHandlerWithPrefix(prefix string) func(http.ResponseWriter, *http.Request) {
	return func(w http.ResponseWriter, req *http.Request) {
		if req.Method != "GET" && req.Method != "HEAD" {
			w.WriteHeader(http.StatusMethodNotAllowed)
			return
		}
		if !strings.HasPrefix(req.URL.Path, prefix) {
			http.NotFound(w, req)
			return
		}
		reqPath := req.URL.Path[len(prefix):]
		if strings.HasPrefix(reqPath, "/") {
			reqPath = reqPath[1:]
		}
		var status = http.StatusOK
		idx, ok := fidx[reqPath]
		if !ok {
			idx, ok = fidx[path.Join(reqPath, "index.html")]
		}
		if !ok {
			http.NotFound(w, req)
			return
		}
		file := &files[idx]
		if tag := req.Header.Get("If-None-Match"); tag != "" {
			if strings.HasPrefix("W/", tag) || strings.HasPrefix("w/", tag) {
				tag = tag[2:]
			}
			if tag, err := strconv.Unquote(tag); err == nil && tag == file.tag {
				w.WriteHeader(http.StatusNotModified)
				return
			}
		}
		if mtime := req.Header.Get("If-Modified-Since"); mtime != "" {
			if ts, err := time.Parse(time.RFC1123, mtime); err == nil && !ts.Before(stamp) {
				w.WriteHeader(http.StatusNotModified)
				return
			}
		}
		var (
			br = file.br
			gz = file.gz
		)
		if encs, ok := req.Header["Accept-Encoding"]; ok {
			var acceptBr, acceptGz bool
			for _, enc := range encs {
				if strings.Contains(enc, "br") {
					acceptBr = true
				}
				if strings.Contains(enc, "gzip") {
					acceptGz = true
				}
			}
			if !acceptBr {
				br = false
			}
			if !acceptGz {
				gz = false
			}
		} else {
			br = false
			gz = false
		}
		header := w.Header()
		switch {
		case br:
			header.Set("Content-Encoding", "br")
			header.Set("Content-Length", strconv.Itoa(len(file.brBlob)))
		case gz:
			header.Set("Content-Encoding", "gzip")
			header.Set("Content-Length", strconv.Itoa(len(file.gzBlob)))
		default:
			header.Set("Content-Length", strconv.Itoa(int(file.size)))
		}
		header.Set("Content-Type", file.mime)
		header.Set("Etag", strconv.Quote(file.tag))
		header.Set("Last-Modified", stamp.Format(time.RFC1123))
		w.WriteHeader(status)
		if req.Method != "HEAD" {
			switch {
			case br:
				w.Write(file.brBlob)
			case gz:
				w.Write(file.gzBlob)
			case file.gz:
				ungzip, _ := gzip.NewReader(bytes.NewReader(file.gzBlob))
				defer ungzip.Close()
				io.Copy(w, ungzip)
			default:
				w.Write(file.gzBlob)
			}
		}
	}
}
